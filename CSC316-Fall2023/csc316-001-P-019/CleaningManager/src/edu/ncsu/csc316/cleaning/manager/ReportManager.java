package edu.ncsu.csc316.cleaning.manager;

import java.io.FileNotFoundException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.Comparator;
import java.util.Iterator;

import edu.ncsu.csc316.cleaning.data.CleaningLogEntry;
import edu.ncsu.csc316.cleaning.data.RoomRecord;
import edu.ncsu.csc316.cleaning.dsa.Algorithm;
import edu.ncsu.csc316.cleaning.dsa.DSAFactory;
import edu.ncsu.csc316.cleaning.dsa.DataStructure;
import edu.ncsu.csc316.cleaning.io.InputReader;
import edu.ncsu.csc316.dsa.list.List;
import edu.ncsu.csc316.dsa.map.Map;
import edu.ncsu.csc316.dsa.map.Map.Entry;
import edu.ncsu.csc316.dsa.sorter.Sorter;

/**
 * This class contains the methods which output the String messages which are displayed when the user interacts with CleaningManagerUI.
 * This class contains an instance of CleaningManager along with a List of RoomRecords and a List of CleaningLogEntrys. This class handles
 * behaviors of outputting the String message of the vacuum bag report, the frequency report, and the general room report.
 * @author Benjamin Uy
 */
public class ReportManager {

	/**
	 * DateTimeFormatter that is used to parse String objects for a date and time in the pattern of MM/dd/yyyy HH:mm:ss
	 */
    public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ofPattern("MM/dd/yyyy HH:mm:ss");
    
    private CleaningManager manager;
	private List<RoomRecord> roomRecords;
	private List<CleaningLogEntry> cleaningLog;

	/**
	 * Constructor method for ReportManager
	 * @param pathToRoomFile pathway to the file containing room information
	 * @param pathToLogFile pathway to the file containing cleaning log information
	 * @param mapType type of map for ReportManager to use
	 * @throws FileNotFoundException if pathToRoomFile or pathToLogFile are not existing files
	 */
    public ReportManager(String pathToRoomFile, String pathToLogFile, DataStructure mapType) throws FileNotFoundException {
        DSAFactory.setListType(DataStructure.ARRAYBASEDLIST);
        DSAFactory.setComparisonSorterType(Algorithm.MERGESORT);
        DSAFactory.setNonComparisonSorterType(Algorithm.RADIX_SORT);
        DSAFactory.setMapType(mapType);
        
        manager = new CleaningManager(pathToRoomFile, pathToLogFile, mapType);
        cleaningLog = InputReader.readLogFile(pathToLogFile);
        roomRecords = InputReader.readRoomFile(pathToRoomFile);
        
        // Private method to sort the cleaning log in chronological order (oldest to newest)
        // By default, whenever a new instance of CleaningManager is created, the cleaningLog is automatically sorted
        cleaningLog = sortByDate(cleaningLog);
        
        // Private method to sort the room records in alphabetical order (A-Z)
        roomRecords = sortByAlphabet(roomRecords);
    }
    
    /**
     * Alternative constructor method for ReportManager
	 * @param pathToRoomFile pathway to the file containing room information
	 * @param pathToLogFile pathway to the file containing cleaning log information
     * @throws FileNotFoundException if pathToRoomFile or pathToLogFile are not existing files
     */
    public ReportManager(String pathToRoomFile, String pathToLogFile) throws FileNotFoundException {
        this(pathToRoomFile, pathToLogFile, DataStructure.SKIPLIST);
    }
    
    /**
     * Custom comparator used to help compare and sort CleaningLogEntry objects
     * @author Benjamin Uy
     */
    private class CleaningLogEntryComparator implements Comparator<CleaningLogEntry> {

    	/**
    	 * Method first sorts CleaningLogEntry objects by their time-stamp, then by their room ID
    	 * @return integer representation of o1's 'position' relative to o2
    	 */
		@Override
		public int compare(CleaningLogEntry o1, CleaningLogEntry o2) {
			if (!o1.getTimestamp().isEqual(o2.getTimestamp())) {
				return o1.getTimestamp().compareTo(o2.getTimestamp());
			} else if (!o1.getRoomID().equalsIgnoreCase(o2.getRoomID())) {
				return o1.getRoomID().compareTo(o2.getRoomID());
			}
			return 0;
		}	
    }
    
    /**
     * Custom comparator used to sort the entries of the map generated by CleaningManager's getEventsByRoom
     * in order of cleaning frequency. Should any entries have lists of CleaningLogEntrys with the same size,
     * the String (representative of the room id) is compared
     * @author Benjamin Uy
     */
    private class MapEntryComparator implements Comparator<Map.Entry<String, List<CleaningLogEntry>>> {

		@Override
		public int compare(Entry<String, List<CleaningLogEntry>> o1, Entry<String, List<CleaningLogEntry>> o2) {
			if (o1.getValue().size() > o2.getValue().size()) {
				return 1;
			} else if (o1.getValue().size() < o2.getValue().size()) {
				return -1;
			}
			// Since we're having the "top" at the end of the array, we also reverse the lexicographical order
			return -(o1.getKey().compareTo(o2.getKey()));
		}
    
    }
    
    /**
     * Private helper method that sorts the given list of CleaningLogEntry objects in ascending chronological time (least recent at the beginning
     * of the list and most recent at the end)
     * @param cleaningLog list of CleaningLogEntry objects to sort.
     * @return sorted list of CleaningLogEntrys in ascending chronological order
     */
	private List<CleaningLogEntry> sortByDate(List<CleaningLogEntry> cleaningLog) {
        Sorter<CleaningLogEntry> cleanArraySorter = DSAFactory.getComparisonSorter(new CleaningLogEntryComparator());
        CleaningLogEntry[] cleanArray = new CleaningLogEntry[cleaningLog.size()];
        
        // Iterate through cleaningLog and store CleaningLogEntry objects in the array
        for (int i = 0; i < cleaningLog.size(); i++) {
        	cleanArray[i] = cleaningLog.get(i);
        }
        // Use the custom comparator sorter to sort the array
        cleanArraySorter.sort(cleanArray);
        
        List<CleaningLogEntry> updatedLog = DSAFactory.getIndexedList(); 
        for (int k = 0; k < cleanArray.length; k++) {
        	updatedLog.addLast(cleanArray[k]);
        }  
        return updatedLog;
	}
	
	/**
	 * Private helper method that sorts the given list of RoomRecord objects in alphabetical order (A-Z)
	 * @param roomRecords list of RoomRecord objects to sort
	 * @return sorted list of RoomRecords in alphabetical order
	 */
	private List<RoomRecord> sortByAlphabet(List<RoomRecord> roomRecords) {
		Sorter<RoomRecord> roomSorter = DSAFactory.getComparisonSorter(null);
		RoomRecord[] roomArray = new RoomRecord[roomRecords.size()];
		
		// Iterate through roomRecords and store roomRecord objects in array
		for (int i = 0; i < roomRecords.size(); i++) {
			roomArray[i] = roomRecords.get(i);		
		}
		
		roomSorter.sort(roomArray);
		
        List<RoomRecord> updatedRooms = DSAFactory.getIndexedList(); 
        for (int k = 0; k < roomArray.length; k++) {
        	updatedRooms.addLast(roomArray[k]);
        }  
        return updatedRooms;
	}

    /**
     * Method returns a report of the approximate remaining lifetime of the vacuum bag.
     * @param timestamp String representation of the date that the vacuum bag was last replaced
     * @return a message detailing when the vacuum bag was last replaced and when, in square feet, the bag needs to be replaced.
     * 		If the given string is incorrectly formatted, then an error message is returned.
     * @throws DateTimeParseException if the given String parameter cannot be parsed by the DateTimeFormatter
     */
    public String getVacuumBagReport(String timestamp) {
    	LocalDateTime date = null;
    	try {
    		date = LocalDateTime.parse(timestamp, DATE_TIME_FORMAT);
    	} catch (DateTimeParseException e) {
    		return "Date & time must be in the format: MM/DD/YYYY HH:MM:SS";
    	}
        
        if (manager.getCoverageSince(date) > 5280) {
        	return "Vacuum Bag Report (last replaced " + timestamp + (") [\n") + ("   Bag is overdue for replacement!\n]");
        } else {
        	return "Vacuum Bag Report (last replaced " + timestamp + (") [\n") + ("   Bag"
        			+ " is due for replacement in " + (5280 - manager.getCoverageSince(date)) + " SQ FT\n]");
        }
    }

    /**
     * Method returns a report of the most frequently cleaned rooms. The input number determines how many rooms are in the report.
     * @param number number of rooms to include in the report
     * @return report of the most frequently cleaned rooms in descending order from most cleaned to least cleaned. Should any rooms have the same
     * 		frequency of cleaning, they will be sorted by alphabetical order. If the number is 0 or negative or if the room and/or clean lists are empty,
     * 		the method will return an error message.
     */
    @SuppressWarnings("unchecked")
	public String getFrequencyReport(int number) {
    	
        if (number <= 0) {
        	return "Number of rooms must be greater than 0.";
        } else if (cleaningLog.size() == 0 || roomRecords.size() == 0) {
        	return "No rooms have been cleaned.";
        } else {
        	if (number >= roomRecords.size()) {
        		number = roomRecords.size();
        	}
        	// Load up a map that has all the rooms and lists of cleaning events
        	Map<String, List<CleaningLogEntry>> map = manager.getEventsByRoom();
        	
        	// Create array that will sort the Rooms by how many times they've been cleaned
        	Map.Entry<String, List<CleaningLogEntry>>[] cleanFrequency = (Entry<String, List<CleaningLogEntry>>[]) new Map.Entry[roomRecords.size()];
        	
        	Iterator<Entry<String, List<CleaningLogEntry>>> it = map.entrySet().iterator();
        	for (int i = 0; i < roomRecords.size(); i++) {
        		cleanFrequency[i] = it.next();
        	}
        	
        	// Use custom comparator to sort the cleanFrequency array
        	DSAFactory.getComparisonSorter(new MapEntryComparator()).sort(cleanFrequency);      	
        	
        	StringBuilder sb = new StringBuilder();
        	
        	sb.append("Frequency of Cleanings [\n");
        	for (int i = 0; i < number; i++) {
        		Map.Entry<String, List<CleaningLogEntry>> e = cleanFrequency[cleanFrequency.length - 1 - i];
        		String name = e.getKey();
        		sb.append("   ").append(name).append(" has been cleaned ").append(e.getValue().size()).append(" times\n");
        	}
        	sb.append("]");
        	
        	return sb.toString();
        }
    }

    /**
     * Method returns a report of the dates and times each room has been cleaned. The report is sorted in
     * ascending alphabetical order by room. For each room, the dates and times are listed in descending
     * chronological order from newest to oldest.
     * @return report of the dates and times each room has been cleaned.
     */
    public String getRoomReport() {
    	if (roomRecords.size() == 0 || cleaningLog.size() == 0) {
    		return "No rooms have been cleaned.";
    	}
    	StringBuilder sb = new StringBuilder();
    	sb.append("Room Report [\n");
    	
    	Map<String, List<CleaningLogEntry>> map = manager.getEventsByRoom();
    	
    	for (int i = 0; i < roomRecords.size(); i++) {
    		sb.append("   ").append(roomRecords.get(i).getRoomID()).append(" was cleaned on [\n");
    		
    		List<CleaningLogEntry> l = map.get(roomRecords.get(i).getRoomID());
    		
    		if (l.size() == 0) {
    			sb.append("      (never cleaned)\n");
    		} else {
	    		for (int k = 0; k < l.size(); k++) {
	    			LocalDateTime time = l.get(k).getTimestamp();
	    			sb.append("      ").append(time.format(DATE_TIME_FORMAT).toString()).append("\n");
	    		}
    		}
    		sb.append("   ]\n");
    	}
    	sb.append("]");
    	
    	return sb.toString();
    }
}